#!/bin/bash
# Main bash configuration file
# Optimized for fast startup with lazy-loading

##-----------------------------------------------------
## Shell Options
##-----------------------------------------------------
# don't put duplicate lines or lines starting with space in the history.
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length
HISTSIZE=1000
HISTFILESIZE=2000

##-----------------------------------------------------
## Path settings (fast - just exports, no evals)
##-----------------------------------------------------

## bin
export PATH="$HOME/.local/bin:$PATH"

## pnpm
export PNPM_HOME="$HOME/.local/share/pnpm"
export PATH="$PNPM_HOME:$PATH"

## rust/cargo (fast - just source env file and PATH)
export CARGO_HOME="$HOME/.local/share/cargo"
export RUSTUP_HOME="$HOME/.local/share/rustup"
[ -f "$CARGO_HOME/env" ] && . "$CARGO_HOME/env"
export PATH="$CARGO_HOME/bin:$PATH"

## go
export GOROOT="$HOME/.local/share/go"
export PATH="$GOROOT/bin:$PATH"
export GOPATH="$HOME/.local/go"
export PATH="$GOPATH/bin:$PATH"

## miniconda - PATH only, no activation (packages available immediately)
export CONDA_DIR="$HOME/.local/share/miniconda"
export PATH="$CONDA_DIR/bin:$PATH"

## opencode
export PATH="$HOME/.opencode/bin:$PATH"

## Lm-Studio
export LM_API_KEY="lm-studio"
export PATH="$HOME/.lmstudio/bin:$PATH"

##-----------------------------------------------------
## NVM - Lazy Loading (saves ~500ms-1s)
##-----------------------------------------------------
export NVM_DIR="$HOME/.local/share/nvm"

# Lazy load nvm - only initialize when needed
_nvm_lazy_load() {
  unset -f nvm node npm npx
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
}

# Create wrapper functions that lazy-load nvm
nvm() {
  _nvm_lazy_load
  nvm "$@"
}
node() {
  _nvm_lazy_load
  node "$@"
}
npm() {
  _nvm_lazy_load
  npm "$@"
}
npx() {
  _nvm_lazy_load
  npx "$@"
}

# Add default node to PATH for non-interactive scripts (if exists)
if [ -d "$NVM_DIR/versions/node" ]; then
  NODE_DEFAULT="$NVM_DIR/alias/default"
  if [ -L "$NODE_DEFAULT" ] || [ -f "$NODE_DEFAULT" ]; then
    DEFAULT_VERSION=$(cat "$NODE_DEFAULT" 2> /dev/null || basename "$(readlink -f "$NODE_DEFAULT")" 2> /dev/null)
    if [ -n "$DEFAULT_VERSION" ] && [ -d "$NVM_DIR/versions/node/$DEFAULT_VERSION" ]; then
      export PATH="$NVM_DIR/versions/node/$DEFAULT_VERSION/bin:$PATH"
    fi
  else
    # Fallback: use the latest installed version
    LATEST_NODE=$(ls -v "$NVM_DIR/versions/node/" 2> /dev/null | tail -1)
    [ -n "$LATEST_NODE" ] && export PATH="$NVM_DIR/versions/node/$LATEST_NODE/bin:$PATH"
  fi
fi

##-----------------------------------------------------
## Ruby/rbenv - Lazy Loading (saves ~200-500ms)
##-----------------------------------------------------
export RBENV_ROOT="$HOME/.local/share/rbenv"
export GEM_HOME="$HOME/.local/share/gem"

# Add ruby binaries to PATH directly (fast, no eval)
if [ -d "$RBENV_ROOT/versions" ]; then
  # Find the global ruby version or use latest
  if [ -f "$RBENV_ROOT/version" ]; then
    RUBY_VERSION=$(cat "$RBENV_ROOT/version")
  else
    RUBY_VERSION=$(ls -v "$RBENV_ROOT/versions/" 2> /dev/null | tail -1)
  fi
  if [ -n "$RUBY_VERSION" ] && [ -d "$RBENV_ROOT/versions/$RUBY_VERSION" ]; then
    export PATH="$RBENV_ROOT/versions/$RUBY_VERSION/bin:$PATH"
    export PATH="$GEM_HOME/ruby/${RUBY_VERSION%.*}.0/bin:$PATH"
  fi
fi
export PATH="$RBENV_ROOT/bin:$PATH"

# Lazy load rbenv - only when rbenv command is used
_rbenv_lazy_load() {
  unset -f rbenv
  eval "$(command "$RBENV_ROOT/bin/rbenv" init - bash)"
}
rbenv() {
  _rbenv_lazy_load
  rbenv "$@"
}

##-----------------------------------------------------
## Conda initialization
##-----------------------------------------------------
# >>> conda initialize >>>
# !! Contents within this block are managed by 'conda init' !!
__conda_setup="$('$CONDA_DIR/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "$CONDA_DIR/etc/profile.d/conda.sh" ]; then
        . "$CONDA_DIR/etc/profile.d/conda.sh"
    else
        export PATH="$CONDA_DIR/bin:$PATH"
    fi
fi
unset __conda_setup
# <<< conda initialize <<<

##-----------------------------------------------------
## Editor
##-----------------------------------------------------
export EDITOR=nvim
export VISUAL="$EDITOR"

##-----------------------------------------------------
## Git
##-----------------------------------------------------
## Load git completion, handling symlinks properly
GIT_COMPLETION="$HOME/.git-completion.bash"
if [[ -e "$GIT_COMPLETION" ]]; then
  if [[ -L "$GIT_COMPLETION" ]]; then
    GIT_COMPLETION=$(readlink -f "$GIT_COMPLETION")
  fi
  if [[ -f "$GIT_COMPLETION" && -r "$GIT_COMPLETION" ]]; then
    . "$GIT_COMPLETION" 2> /dev/null
  fi
elif [[ -f "/usr/share/bash-completion/completions/git" ]]; then
  . "/usr/share/bash-completion/completions/git"
fi

export GITHUB_USERNAME="jrestrepo86"

# Token file locations
GITHUB_TOKEN_FILE="$HOME/Dropbox/scripts/tokens/gitHubToken.txt"
BITBUCKET_TOKEN_FILE="$HOME/Dropbox/scripts/tokens/bitBucketToken.txt"

## Secure token handling functions
gtoken() {
  if [[ -r "$GITHUB_TOKEN_FILE" ]]; then
    cat "$GITHUB_TOKEN_FILE"
    command -v xclip &> /dev/null && xclip -sel clip < "$GITHUB_TOKEN_FILE"
  else
    echo "GitHub token file not found or not readable" >&2
    return 1
  fi
}

btoken() {
  if [[ -r "$BITBUCKET_TOKEN_FILE" ]]; then
    cat "$BITBUCKET_TOKEN_FILE"
    command -v xclip &> /dev/null && xclip -sel clip < "$BITBUCKET_TOKEN_FILE"
  else
    echo "Bitbucket token file not found or not readable" >&2
    return 1
  fi
}

##-----------------------------------------------------
## Functions
##-----------------------------------------------------
## cdf() - cd into the directory of the selected file
cdf() {
  local file dir
  file=$(fzf -e -q "$*") && dir=$(dirname "$file") && cd "$dir" || return
}

## cdh() - cd from home
cdh() {
  local file dir
  file=$(locate ~ | fzf -e -q "$*") && dir=$(dirname "$file") && cd "$dir" || return
}

## ff() - Fast find directory
ff() {
  local query="${*:-}" dir
  dir="$(fd -H -t d . "$HOME" 2> /dev/null | fzf +m --prompt='cd > ' --query="$query" --select-1 --exit-0)" || return
  [ -n "$dir" ] && cd "$dir" || return
}

## Fast activate conda env with fzf selector
cenv() {
  local env
  env="$(conda info --envs 2> /dev/null | awk 'NF && $1 !~ /^#/ {print $1}' | fzf +m --prompt='conda env > ' --select-1 --exit-0)" || return
  [ -n "$env" ] && conda activate "$env"
}

## Fast deactivate: one level (default), --to-base, or --all
cdeact() {
  case "${1:-one}" in
    --all)
      while [ "${CONDA_SHLVL:-0}" -gt 0 ]; do conda deactivate || break; done
      ;;
    --to-base)
      while [ "${CONDA_SHLVL:-0}" -gt 0 ] && [ "${CONDA_DEFAULT_ENV-}" != "base" ]; do
        conda deactivate || break
      done
      ;;
    -*)
      echo "Usage: cdeact [--all | --to-base]" >&2
      return 2
      ;;
    *)
      conda deactivate
      ;;
  esac
}

## fast config pick
cfg() {
  local base="${XDG_CONFIG_HOME:-$HOME/.config}"
  [ -d "$base" ] || {
    echo "No config dir: $base" >&2
    return 1
  }
  local p
  p="$(fd -H -t d . "$base" -d 1 2> /dev/null | sort | fzf +m --prompt='~/.config/ ' --select-1 --exit-0 --preview 'ls -la {} | head -20')" || return
  [ -n "$p" ] && cd "$p"
}

## matlab
matlab() {
  export GTK_PATH='/usr/lib/x86_64-linux-gnu/gtk-2.0'
  command matlab "$@"
}

##-----------------------------------------------------
## Alias
##-----------------------------------------------------
## Load .bash_aliases if it exists
[ -f ~/.bash_aliases ] || [ -L ~/.bash_aliases ] && . ~/.bash_aliases

##-----------------------------------------------------
## Bash completion (load only if interactive)
##-----------------------------------------------------
if [[ $- == *i* ]] && ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

##-----------------------------------------------------
## Julia
##-----------------------------------------------------
case ":$PATH:" in
  *:/home/jrestrepo/.juliaup/bin:*) ;;
  *) export PATH="/home/jrestrepo/.juliaup/bin${PATH:+:${PATH}}" ;;
esac

##-----------------------------------------------------
## Ollama autocomplete (only if ollama exists)
##-----------------------------------------------------
if command -v ollama &> /dev/null; then
  _complete_ollama() {
    local cur prev words cword
    _init_completion -n : || return
    if [[ $cword -eq 1 ]]; then
      local -a commands=(serve create show run push pull list ps cp rm help)
      mapfile -t COMPREPLY < <(compgen -W "${commands[*]}" -- "$cur")
    elif [[ $cword -eq 2 ]]; then
      case "$prev" in
        run | show | cp | rm | push | list)
          local -a models
          mapfile -t models < <(ollama list 2> /dev/null | tail -n +2 | cut -d $'\t' -f 1)
          mapfile -t COMPREPLY < <(compgen -W "${models[*]}" -- "$cur")
          __ltrim_colon_completions "$cur"
          ;;
      esac
    fi
  }
  complete -F _complete_ollama ollama
fi

export GEMINI_API_KEY="AIzaSyBOM_awbt5OzTq5TmNtmPEfSfhMy9-mu3I"

##-----------------------------------------------------
## Starship Prompt
##-----------------------------------------------------
eval "$(starship init bash)"
