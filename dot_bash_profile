# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000
##-----------------------------------------------------
## Keys
##-----------------------------------------------------
##-----------------------------------------------------
## Path settings
##-----------------------------------------------------
## bin
PATH="$HOME/.local/bin:$PATH"
## go
PATH="$HOME/.local/go/bin:$PATH"
export GOPATH="$HOME/.local/go"
## miniconda
export CONDA_PATH="$HOME/.local/share/miniconda/bin"
PATH="$CONDA_PATH:$PATH"
## cargo
export CARGO_HOME="$HOME/.local/share/cargo"
export RUSTUP_HOME="$HOME/.local/share/rustup"
source "$CARGO_HOME/env"
PATH="$CARGO_HOME/bin:$PATH"
## pnpm
export PNPM_HOME="$HOME/.local/share/pnpm"
PATH="$PNPM_HOME:$PATH"
# nvm
export NVM_DIR="$HOME/.local/share/nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"                   # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion
# opencode
export PATH=$HOME/.opencode/bin:$PATH
# Lm-Studio
export LM_API_KEY="lm-studio"
export PATH="$PATH:$HOME/.lmstudio/bin"

##-----------------------------------------------------
## Editor
##-----------------------------------------------------
export EDITOR=nvim
export VISUAL="$EDITOR"
##-----------------------------------------------------
## Git
##-----------------------------------------------------
# Load git completion, handling symlinks properly
GIT_COMPLETION="$HOME/.git-completion.bash"
if [[ -e "$GIT_COMPLETION" ]]; then
  if [[ -L "$GIT_COMPLETION" ]]; then
    # Resolve symlink to its actual path
    GIT_COMPLETION=$(readlink -f "$GIT_COMPLETION")
  fi

  if [[ -f "$GIT_COMPLETION" && -r "$GIT_COMPLETION" ]]; then
    # shellcheck disable=SC1090  # Can't verify dynamic source
    if source "$GIT_COMPLETION"; then
      : # Successfully loaded
    else
      echo "Note: Git completion loaded but returned error" >&2
    fi
  else
    echo "Warning: Git completion file exists but is not readable" >&2
  fi
else
  # Fallback to system installation if available
  SYSTEM_GIT_COMPLETION="/usr/share/bash-completion/completions/git"
  if [[ -f "$SYSTEM_GIT_COMPLETION" && -r "$SYSTEM_GIT_COMPLETION" ]]; then
    # shellcheck disable=SC1090
    source "$SYSTEM_GIT_COMPLETION"
  fi
fi
export GITHUB_USERNAME="jrestrepo86"
# Token file locations (using proper path expansion)
GITHUB_TOKEN_FILE="$HOME/Dropbox/scripts/tokens/gitHubToken.txt"
BITBUCKET_TOKEN_FILE="$HOME/Dropbox/scripts/tokens/bitBucketToken.txt"
# Secure token handling functions
gtoken() {
  if [[ -r "$GITHUB_TOKEN_FILE" ]]; then
    cat "$GITHUB_TOKEN_FILE"
    if command -v xclip &>/dev/null; then
      xclip -sel clip <"$GITHUB_TOKEN_FILE"
    else
      echo "xclip not found - token not copied to clipboard" >&2
    fi
  else
    echo "GitHub token file not found or not readable" >&2
    return 1
  fi
}

btoken() {
  if [[ -r "$BITBUCKET_TOKEN_FILE" ]]; then
    cat "$BITBUCKET_TOKEN_FILE"
    if command -v xclip &>/dev/null; then
      xclip -sel clip <"$BITBUCKET_TOKEN_FILE"
    else
      echo "xclip not found - token not copied to clipboard" >&2
    fi
  else
    echo "Bitbucket token file not found or not readable" >&2
    return 1
  fi
}
# Export only if needed by other scripts
# export GITHUB_TOKEN_FILE BITBUCKET_TOKEN_FILE
##-----------------------------------------------------
## Functions
##-----------------------------------------------------
## cdf() - cd into the directory of the selected file
cdf() {
  local file
  local dir
  file=$(fzf -e -q "$*") && dir=$(dirname "$file") && cd "$dir" || return
}
## cdh() - cd from home
cdh() {
  local file
  local dir
  file=$(locate ~ | fzf -e -q "$*") && dir=$(dirname "$file") && cd "$dir" || return
}
ff() {
  local query="${*:-}" dir
  dir="$(
    fdfind -H -t d . "$HOME" 2>/dev/null |
      fzf +m --prompt='cd > ' --query="$query" --select-1 --exit-0
  )" || return
  [ -n "$dir" ] && cd "$dir" || return
}

# Load conda hook on demand, no auto-activation
_load_conda_hook() {
  local shname="$(basename "$SHELL")"
  eval "$("conda" "shell.${shname}" "hook" 2>/dev/null)" ||
    { base="$(conda info --base 2>/dev/null)" &&
      [ -f "$base/etc/profile.d/conda.sh" ] &&
      . "$base/etc/profile.d/conda.sh"; } || return 1
}
# Fast deactivate: one level (default), --to-base, or --all
cdeact() {
  _load_conda_hook || {
    echo "Run: conda init $(basename "$SHELL")" >&2
    return 1
  }
  case "${1:-one}" in
  --all)
    while [ "${CONDA_SHLVL:-0}" -gt 0 ]; do conda deactivate || break; done
    ;;
  --to-base)
    while [ "${CONDA_SHLVL:-0}" -gt 0 ] && [ "${CONDA_DEFAULT_ENV-}" != "base" ]; do
      conda deactivate || break
    done
    ;;
  -*)
    echo "Usage: cdeact [--all | --to-base]" >&2
    return 2
    ;;
  *)
    conda deactivate
    ;;
  esac
}
cenv() {
  _load_conda_hook || {
    echo "Run: conda init $(basename "$SHELL")"
    return 1
  }
  local env
  env="$(
    conda info --envs 2>/dev/null |
      awk 'NF && $1 !~ /^#/ {print $1}' |
      fzf +m --prompt='conda env > ' --select-1 --exit-0
  )" || return
  [ -n "$env" ] && conda activate "$env"
}

cfgpick() {
  local base="${XDG_CONFIG_HOME:-$HOME/.config}"
  [ -d "$base" ] || {
    echo "No config dir: $base" >&2
    return 1
  }
  fdfind -H -t d . "$base" -d 1 2>/dev/null |
    sort |
    fzf +m --prompt='~/.config/ ' --select-1 --exit-0 \
      --preview 'ls -la {} | sed -n "1,200p"'
}
cfg() {
  local p
  p="$(cfgpick)" || return
  [ -n "$p" ] && cd "$p"
}

# -----------------------------------------------------------

# ----------------------------------------------

## matlab
function matlab() {
  export GTK_PATH='/usr/lib/x86_64-linux-gnu/gtk-2.0'
  command matlab "$@"
}
##-----------------------------------------------------
## Alias
##-----------------------------------------------------
## Own alias
# Load .bash_aliases if it exists (even if it's a symlink)
if [ -f ~/.bash_aliases ] || [ -L ~/.bash_aliases ]; then
  # shellcheck disable=SC1090
  . ~/.bash_aliases
fi

##-----------------------------------------------------
## Bash completion
##-----------------------------------------------------
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    # shellcheck disable=SC1091
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    # shellcheck disable=SC1091
    . /etc/bash_completion
  fi
fi
##-----------------------------------------------------

# !! Contents within this block are managed by juliaup !!
case ":$PATH:" in
*:/home/jrestrepo/.juliaup/bin:*) ;;

*)
  export PATH=/home/jrestrepo/.juliaup/bin${PATH:+:${PATH}}
  ;;
esac

# llama autocomplete
_complete_ollama() {
  local cur prev words cword
  _init_completion -n : || return

  if [[ $cword -eq 1 ]]; then
    # Safe fixed list of commands - doesn't need mapfile
    local -a commands=(
      serve create show run push pull list ps cp rm help
    )
    # Use printf to avoid word splitting
    mapfile -t COMPREPLY < <(compgen -W "${commands[*]}" -- "$cur")
  elif [[ $cword -eq 2 ]]; then
    case "$prev" in
    run | show | cp | rm | push | list)
      local -a models
      # Use mapfile to safely read command output into array
      mapfile -t models < <(ollama list 2>/dev/null | tail -n +2 | cut -d $'\t' -f 1)
      # Safely generate completions
      mapfile -t COMPREPLY < <(compgen -W "${models[*]}" -- "$cur")
      __ltrim_colon_completions "$cur"
      ;;
    esac
  fi
}
complete -F _complete_ollama ollama

# if ! activate_base; then
#   # Handle activation failure
#   echo "Conda activation failed, proceeding without it"
# fi

# # Auto-Warpify
# # printf ''
# if [ -n "${PS1:-}" ]; then
#   printf '^[P$f{"hook": "SourcedRcFileForWarp", "value": { "shell": "bash", "uname": "Linux" }}<9c>'
# fi
